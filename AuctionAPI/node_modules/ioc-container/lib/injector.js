'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function Injector() {
    _classCallCheck(this, Injector);

    this._factories = {};
    this._instances = {};
    this._sourceStacks = {};
    this._groups = {};
    this._allowedGroupDependencies = {};
    this._deniedGroupDependencies = {};

    this.addGroupServices('injectors', {
      injector: this
    });
  }

  _createClass(Injector, [{
    key: '_addService',
    value: function _addService(key, factory) {
      var groups = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var stack = this._parseStack(new Error().stack);
      if (this._instances[key] || this._factories[key]) {
        this._warnAboutMultipleDefinitions(key, stack);
      }

      if (typeof factory === 'function') {
        this._factories[key] = factory;
      } else {
        this._instances[key] = factory;
      }

      if (groups) {
        this._addServiceToGroups(groups, key);
      }

      this._sourceStacks[key] = stack;
    }
  }, {
    key: 'addServices',
    value: function addServices(services) {
      var _this = this;

      Object.keys(services).forEach(function (key) {
        var service = services[key];
        _this._addService(key, service, null);
      });
    }
  }, {
    key: 'addGroupServices',
    value: function addGroupServices(groups, services) {
      var _this2 = this;

      groups = Array.isArray(groups) ? groups : [groups];

      Object.keys(services).forEach(function (key) {
        var service = services[key];
        _this2._addService(key, service, groups);
      });
    }
  }, {
    key: 'getServices',
    value: function getServices() {
      var _this3 = this;

      for (var _len = arguments.length, groups = Array(_len), _key = 0; _key < _len; _key++) {
        groups[_key] = arguments[_key];
      }

      if (groups.length === 0) {
        return this.getAllServices();
      }

      var services = {};
      var keys = [];

      groups.forEach(function (group) {
        var groupServiceKeys = _this3._groups[group];
        groupServiceKeys.forEach(function (key) {
          if (keys.indexOf(key) > -1) {
            return;
          }

          if (_this3._instances[key]) {
            services[key] = _this3._instances[key];
          } else if (_this3._factories[key]) {
            Object.defineProperty(services, key, {
              enumerable: true,
              get: _this3.getService.bind(_this3, key)
            });
          }
        });
      });

      return services;
    }
  }, {
    key: 'getAllServices',
    value: function getAllServices() {
      var _this4 = this;

      var services = _extends({}, this._instances);

      Object.keys(this._factories).forEach(function (key) {
        var factory = _this4._factories[key];
        if (typeof services[key] === 'undefined') {
          Object.defineProperty(services, key, {
            enumerable: true,
            get: _this4.getService.bind(_this4, key)
          });
        }
      });

      return services;
    }
  }, {
    key: 'getAllServicesAs',
    value: function getAllServicesAs(group) {
      var _this5 = this;

      var groupPolicy = this._getGroupPolicy(group);
      if (!groupPolicy.limited) {
        return this.getAllServices();
      }

      var isAllowedForGroup = function isAllowedForGroup(key) {
        var denied = groupPolicy.deniedDependencies.indexOf(key) !== -1;
        var allowed = groupPolicy.allowedDependencies.indexOf(key) !== -1;
        return allowed || !denied;
      };

      var services = {};
      Object.keys(this._instances).forEach(function (key) {
        if (isAllowedForGroup(key)) {
          services[key] = _this5._instances[key];
        }
      });

      Object.keys(this._factories).forEach(function (key) {
        if (typeof services[key] === 'undefined' && isAllowedForGroup(key)) {
          Object.defineProperty(services, key, {
            enumerable: true,
            get: _this5.getService.bind(_this5, key)
          });
        }
      });

      return services;
    }

    /**
     * Adds a new service definition unless a service of the provided key has
     * already been defined.
     * @param {string} key A service key.
     * @param {!Function} factory A service factory or a constructor.
     * @param {(Array.<string>|string|null)=} groups A service group list.
     *   If (there already is a service with the same provided key, the service is)
     *   still added to the provided group(s).
     */

  }, {
    key: '_addNewService',
    value: function _addNewService(key, factory) {
      var groups = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (this._instances[key] || this._factories[key]) {
        if (groups) {
          this._addServiceToGroups(groups, key);
        }
        return;
      }

      this._addService(key, factory, groups);
    }
  }, {
    key: 'addNewGroupServices',
    value: function addNewGroupServices(groups, services) {
      var _this6 = this;

      groups = Array.isArray(groups) ? groups : [groups];

      Object.keys(services).forEach(function (key) {
        var service = services[key];
        _this6._addNewService(key, service, groups);
      });
    }
  }, {
    key: 'addNewServices',
    value: function addNewServices(services) {
      var _this7 = this;

      Object.keys(services).forEach(function (key) {
        var service = services[key];
        _this7._addNewService(key, service, null);
      });
    }

    /**
     * Adds the service of the provided key to the provided groups.
     * Groups are a way of defining permission relationships between services
     * in the sense of "who can request whom".
     * @param {!Array.<string>|string} groups A service group list.
     * @param {string} key A service key.
     */

  }, {
    key: '_addServiceToGroups',
    value: function _addServiceToGroups(groups, key) {
      var _this8 = this;

      if (!groups) {
        return;
      }

      if (Array.isArray(groups)) {
        groups.forEach(function (group) {
          _this8._addServiceToGroup(group, key);
        });
      } else {
        this._addServiceToGroup(groups, key);
      }
    }

    /**
     * Adds the service of the provided key to the provided group.
     * Groups are a way of defining permission relationships between services
     * in the sense of "who can request whom".
     * @param {string} group A service group.
     * @param {string} key A service key.
     */

  }, {
    key: '_addServiceToGroup',
    value: function _addServiceToGroup(group, key) {
      this._groups[group] = this._groups[group] || [];
      if (this._groups[group].indexOf(key) === -1) {
        this._groups[group].push(key);
      }
    }
  }, {
    key: 'allowGroupDependency',
    value: function allowGroupDependency(group, dependencyGroup) {
      this._allowedGroupDependencies[group] = this._allowedGroupDependencies[group] || [];
      if (this._allowedGroupDependencies[group].indexOf(dependencyGroup) === -1) {
        this._allowedGroupDependencies[group].push(dependencyGroup);
      }
    }
  }, {
    key: 'denyGroupDependency',
    value: function denyGroupDependency(group, dependencyGroup) {
      this._deniedGroupDependencies[group] = this._deniedGroupDependencies[group] || [];
      if (this._deniedGroupDependencies[group].indexOf(dependencyGroup) === -1) {
        this._deniedGroupDependencies[group].push(dependencyGroup);
      }
    }

    /**
     * Returns an existing service instance, otherwise requests a new instance
     * and returns that if (a service of the provided key is defined.)
     * @param {string} key A service key.
     * @return {Object} A service instance.
     */

  }, {
    key: 'getService',
    value: function getService(key) {
      var instance = this._instances[key];
      if (instance) {
        return instance;
      }

      var Constructor = this._factories[key];
      if (!Constructor) {
        return null;
      }

      var groups = this._getGroupsOfService(key);
      if (groups.length === 0) {
        instance = this.create(Constructor);
      } else {
        instance = this._createGroupMember(Constructor, groups, key);
      }

      this._instances[key] = instance;
      return instance;
    }

    /**
     * Creates a new instance using the provided factory or a constructor.
     * A dependency list is read from the argument list of the function.
     * Any extra arguments are passed prepended to the argument list applied
     * to the factory.
     * @param {!Function} Constructor A service factory or a constructor.
     * @param {...*} args Arguments to pass to the factory/constructor.
     * @return {!Object} A new instance.
     */

  }, {
    key: 'create',
    value: function create(Constructor) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this.createInGroup.apply(this, [Constructor, null].concat(args));
    }
  }, {
    key: 'createInGroup',
    value: function createInGroup(Constructor, groups) {
      var name = Constructor.name;

      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      return this._createGroupMember.apply(this, [Constructor, groups, name].concat(args));
    }
  }, {
    key: '_createGroupMember',
    value: function _createGroupMember(Constructor, groups, dependantKey) {
      var depTypes = this._getDependencyList(Constructor) || {};
      var depKeys = Object.keys(depTypes);

      if (Array.isArray(groups)) {
        this._validateDependencyList(depKeys, groups, dependantKey);
      } else if (groups) {
        this._validateDependencyList(depKeys, [groups], dependantKey);
      }

      for (var _len4 = arguments.length, args = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
        args[_key4 - 3] = arguments[_key4];
      }

      return this._createWithDependencyList.apply(this, [Constructor, depTypes, dependantKey].concat(args));
    }
  }, {
    key: '_createWithDependencyList',
    value: function _createWithDependencyList(Constructor, depTypes, dependantKey) {
      var _this9 = this;

      var services = {};
      Object.keys(depTypes).forEach(function (depKey) {
        var depType = depTypes[depKey];
        var dep = _this9.getService(depKey);
        if (!dep) {
          var message = 'Dependency not provided: ' + dependantKey + '(' + depKey + ')';
          if (depType === false) {
            console.warn('[Injector] ' + message);
          } else {
            throw new Error(message);
          }
        }

        services[depKey] = dep;
      });

      for (var _len5 = arguments.length, args = Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {
        args[_key5 - 3] = arguments[_key5];
      }

      try {
        return Reflect.construct(Constructor, [].concat(args, [services]));
      } catch (err) {
        try {
          return Constructor.apply(undefined, args.concat([services])) || null;
        } catch (subErr) {
          var message = 'Failed to instantiate service: ' + dependantKey;
          console.error('[Injector] ' + message + '\n', err, '\n', subErr);
          throw new Error(message);
        }
      }
    }
  }, {
    key: '_getGroupsOfService',
    value: function _getGroupsOfService(key) {
      var _this10 = this;

      var groups = [];
      Object.keys(this._groups).forEach(function (group) {
        var keys = _this10._groups[group];
        if (keys.indexOf(key) !== -1) {
          groups.push(group);
        }
      });

      return groups;
    }
  }, {
    key: '_getDependencyList',
    value: function _getDependencyList(Constructor) {
      var serviceTypes = (Constructor.prototype ? Constructor.prototype.serviceTypes : null) || Constructor.serviceTypes;

      if (serviceTypes) {
        return serviceTypes;
      }

      var name = Constructor.name;
      if (name) {
        console.debug('[Injector] The constructor/factory "' + name + '" does not provide a service list. ' + 'No services will be injected.');
      }

      return null;
    }
  }, {
    key: '_validateDependencyList',
    value: function _validateDependencyList(depKeys, groups, dependantKey) {
      var groupPolicy = this._getGroupPolicyAggregation(groups);
      if (!groupPolicy.limited) {
        return;
      }

      depKeys.forEach(function (depKey) {
        var denied = groupPolicy.deniedDependencies.indexOf(depKey) !== -1;
        var allowed = groupPolicy.allowedDependencies.indexOf(depKey) !== -1;
        if (denied && !allowed) {
          throw new Error('Denied access to dependency: ' + dependantKey + '(' + depKey + ')');
        }
      });
    }
  }, {
    key: '_getGroupPolicyAggregation',
    value: function _getGroupPolicyAggregation(groups) {
      var _this11 = this;

      var policy = {
        limited: false,
        allowedDependencies: [],
        deniedDependencies: []
      };

      groups.forEach(function (group) {
        var groupPolicy = _this11._getGroupPolicy(group);
        if (groupPolicy.limited) {
          policy.limited = true;

          policy.allowedDependencies = groupPolicy.allowedDependencies.reduce(function (allowedDependencies, depKey) {
            return allowedDependencies.indexOf(depKey) === -1 ? allowedDependencies.concat([depKey]) : allowedDependencies;
          }, policy.allowedDependencies);

          policy.deniedDependencies = groupPolicy.deniedDependencies.reduce(function (deniedDependencies, depKey) {
            return deniedDependencies.indexOf(depKey) === -1 ? deniedDependencies.concat([depKey]) : deniedDependencies;
          }, policy.deniedDependencies);
        }
      });

      return policy;
    }
  }, {
    key: '_getGroupPolicy',
    value: function _getGroupPolicy(group) {
      var allowedDepKeys = this._allowedGroupDependencies[group] || [];
      var deniedDepKeys = this._deniedGroupDependencies[group] || [];

      var groupPolicy = {
        limited: allowedDepKeys.length > 0 || deniedDepKeys.length > 0,
        allowedDependencies: this._collectGroupDependencies(group, allowedDepKeys),
        deniedDependencies: this._collectGroupDependencies(group, deniedDepKeys)
      };

      return groupPolicy;
    }
  }, {
    key: '_collectGroupDependencies',
    value: function _collectGroupDependencies(group, groupDependencies) {
      var _this12 = this;

      return groupDependencies.reduce(function (results, dependencyGroup) {
        return (_this12._groups[dependencyGroup] || []).reduce(function (results, key) {
          return results.indexOf(key) === -1 ? results.concat([key]) : results;
        }, results);
      }, []);
    }
  }, {
    key: '_parseStack',
    value: function _parseStack(rawStack) {
      var stackLines = rawStack.split('\n');
      var stack = stackLines.slice(2).join('\n');
      return stack;
    }
  }, {
    key: '_warnAboutMultipleDefinitions',
    value: function _warnAboutMultipleDefinitions(key, stack) {
      var originalStack = this._sourceStacks[key];
      console.warn('[Injector] Service \'' + key + '\' is being overwritten.' + ('Newly defined at: ' + stack) + ('Originally defined at: ' + originalStack));
    }
  }]);

  return Injector;
}();